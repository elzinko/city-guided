name: CI/CD

on:
  workflow_dispatch:
    inputs:
      deploy_staging:
        description: "Deploy to AWS staging after tests"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]
  push:
    branches: ["main", "feature/**", "bugfix/**"]
  pull_request:
    branches: ["main"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENVIRONMENT VARIABLES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
env:
  AWS_REGION: 'eu-west-3'

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & TEST (Single build, cached for all subsequent jobs)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-and-test:
    name: Build & Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Install dependencies
        env:
          HUSKY: 0
        run: pnpm install --frozen-lockfile --ignore-scripts

      - name: Lint
        run: pnpm run lint

      - name: Build
        run: pnpm run build

      - name: Unit Tests
        run: pnpm run test

      - name: Cache build artifacts
        uses: actions/cache/save@v4
        with:
          path: |
            apps/*/dist
            apps/*/.next
            services/*/dist
            packages/*/dist
            node_modules
            .turbo
          key: build-${{ github.sha }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # E2E TESTS (Uses cached build artifacts)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: build-and-test
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            apps/*/dist
            apps/*/.next
            services/*/dist
            packages/*/dist
            .turbo
          key: build-${{ github.sha }}

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Install dependencies (fast with cached store)
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm --filter apps-web-frontend exec playwright install --with-deps chromium

      - name: Generate .env.ci file
        run: |
          mkdir -p infra/config
          cat > infra/config/.env.ci << 'EOF'
          ENVIRONMENT=ci
          PROJECT_NAME=city-guided-ci
          SITE_DOMAIN=localhost
          API_PORT=4000
          WEB_PORT=3080
          OSRM_PORT=5001
          OSRM_URL=http://osrm:5000
          BUILD_MODE=local
          SHOULD_BUILD_LOCAL=true
          RESTART_POLICY=no
          NODE_ENV=test
          NEXT_PUBLIC_SHOW_DEV_OPTIONS=false
          DOCKER_ENV=true
          EOF

      - name: Start all services (using .env.ci)
        run: SKIP_OSRM_DATA_LOAD=true pnpm docker:start ci
        timeout-minutes: 5

      - name: Check container status
        run: |
          echo "ğŸ“‹ Container status:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ""
          echo "ğŸ“‹ Container logs (last 20 lines each):"
          docker logs city-guided-ci-api --tail 20 2>&1 || echo "API container not found"
          docker logs city-guided-ci-web --tail 20 2>&1 || echo "Web container not found"
          docker logs city-guided-ci-caddy --tail 20 2>&1 || echo "Caddy container not found"

      - name: Wait for all services
        run: SKIP_OSRM_DATA_LOAD=true pnpm docker:wait ci all
        timeout-minutes: 5

      - name: Run E2E tests
        run: pnpm run test:e2e
        env:
          # Tests via Caddy reverse proxy (port 80)
          E2E_BASE_URL: http://localhost
          NEXT_PUBLIC_API_URL: http://localhost/api
          NEXT_PUBLIC_OSRM_URL: http://localhost/osrm

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: apps/web-frontend/test-results/
          retention-days: 7

      - name: Show logs on failure
        if: failure()
        run: pnpm docker:logs ci

      - name: Cleanup
        if: always()
        run: pnpm docker:stop ci

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD AND PUSH DOCKER IMAGES TO AWS ECR
  # Uses cached build artifacts from build-and-test job for faster builds
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-images:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [build-and-test, e2e-tests]
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      api_image: ${{ steps.ecr-repos.outputs.api_repo }}:${{ steps.meta.outputs.version }}
      web_image: ${{ steps.ecr-repos.outputs.web_repo }}:${{ steps.meta.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Restore build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            apps/*/dist
            apps/*/.next
            services/*/dist
            packages/*/dist
            node_modules
            .turbo
          key: build-${{ github.sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.SECRET_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.SECRET_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Get ECR repository URIs
        id: ecr-repos
        run: |
          API_REPO=$(aws ecr describe-repositories --repository-names city-guided-api --region ${{ env.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
          WEB_REPO=$(aws ecr describe-repositories --repository-names city-guided-web --region ${{ env.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
          echo "api_repo=${API_REPO}" >> $GITHUB_OUTPUT
          echo "web_repo=${WEB_REPO}" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ API Repository: ${API_REPO}"
          echo "ğŸ“¦ Web Repository: ${WEB_REPO}"

      - name: Generate image tag
        id: meta
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Image tag: ${SHORT_SHA}"

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: infra/deployment/compose/Dockerfile.api
          push: true
          tags: |
            ${{ steps.ecr-repos.outputs.api_repo }}:${{ steps.meta.outputs.version }}
            ${{ steps.ecr-repos.outputs.api_repo }}:latest
            ${{ steps.ecr-repos.outputs.api_repo }}:main
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: infra/deployment/compose/Dockerfile.frontend
          push: true
          tags: |
            ${{ steps.ecr-repos.outputs.web_repo }}:${{ steps.meta.outputs.version }}
            ${{ steps.ecr-repos.outputs.web_repo }}:latest
            ${{ steps.ecr-repos.outputs.web_repo }}:main
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘            ğŸ“¦ Docker Images Built                       â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ·ï¸ Tag: ${{ steps.meta.outputs.version }}"
          echo "ğŸ“¦ API: ${{ steps.ecr-repos.outputs.api_repo }}:${{ steps.meta.outputs.version }}"
          echo "ğŸ“¦ Web: ${{ steps.ecr-repos.outputs.web_repo }}:${{ steps.meta.outputs.version }}"
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEPLOY TO STAGING (ECS Fargate)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-staging:
    name: Deploy to AWS Staging
    runs-on: ubuntu-latest
    needs: [build-images]
    if: |
      github.ref == 'refs/heads/main' &&
      (
        github.event_name == 'push' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_staging == 'true')
      )
    environment:
      name: staging
      url: https://cityguided.duckdns.org
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.SECRET_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.SECRET_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy application
        env:
          IMAGE_TAG: ${{ needs.build-images.outputs.image_tag }}
        run: |
          echo "ğŸš€ Deploying to AWS staging (ECS Fargate)..."
          echo "   Image tag: $IMAGE_TAG"
          echo ""
          
          pnpm app:deploy staging --tag "$IMAGE_TAG"

      - name: Get ALB DNS
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names city-guided-alb \
            --region ${{ env.AWS_REGION }} \
            --query 'LoadBalancers[0].DNSName' \
            --output text 2>/dev/null || echo "")
          echo "dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ğŸŒ ALB DNS: $ALB_DNS"

      - name: Get site domain from SSM
        id: ssm
        run: |
          SITE_DOMAIN=$(aws ssm get-parameter --name "/city-guided/staging/SITE_DOMAIN" --query "Parameter.Value" --output text 2>/dev/null || echo "cityguided.duckdns.org")
          echo "site_domain=$SITE_DOMAIN" >> $GITHUB_OUTPUT

      - name: Update DuckDNS (if reverse proxy is enabled)
        if: vars.DUCKDNS_ENABLED == 'true'
        run: |
          echo "ğŸ¦† Updating DuckDNS with reverse proxy Elastic IP..."
          
          # Get Elastic IP from the reverse proxy stack
          ELASTIC_IP=$(aws ec2 describe-addresses \
            --filters "Name=tag:Name,Values=city-guided-proxy" \
            --region ${{ env.AWS_REGION }} \
            --query 'Addresses[0].PublicIp' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$ELASTIC_IP" ]; then
            echo "âš ï¸ No reverse proxy Elastic IP found. Skipping DuckDNS update."
            echo "   To enable: Deploy the reverse proxy stack first."
            exit 0
          fi
          
          # Extract domain name from full domain (e.g., cityguided from cityguided.duckdns.org)
          DUCKDNS_DOMAIN=$(echo "${{ steps.ssm.outputs.site_domain }}" | sed 's/.duckdns.org$//')
          
          # Update DuckDNS
          RESPONSE=$(curl -s "https://www.duckdns.org/update?domains=${DUCKDNS_DOMAIN}&token=${{ secrets.DUCKDNS_TOKEN }}&ip=${ELASTIC_IP}")
          
          if [ "$RESPONSE" = "OK" ]; then
            echo "âœ… DuckDNS updated successfully"
            echo "   Domain: ${DUCKDNS_DOMAIN}.duckdns.org"
            echo "   IP: ${ELASTIC_IP}"
          else
            echo "âŒ DuckDNS update failed: $RESPONSE"
            exit 1
          fi

      - name: Verify ECS deployment
        run: |
          echo "ğŸ” Verifying ECS deployment..."
          echo ""
          
          # Get service status
          aws ecs describe-services \
            --cluster city-guided-cluster \
            --services city-guided-service \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,Desired:desiredCount,Running:runningCount,Pending:pendingCount}' \
            --output table
          
          echo ""
          echo "ğŸ“Š Target Group Health:"
          
          # Get target group ARN (CDK-generated name)
          TG_ARN=$(aws elbv2 describe-target-groups \
            --region ${{ env.AWS_REGION }} \
            --query "TargetGroups[?contains(TargetGroupName, 'CityGu')].TargetGroupArn" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$TG_ARN" ]; then
            aws elbv2 describe-target-health \
              --target-group-arn "$TG_ARN" \
              --region ${{ env.AWS_REGION }} \
              --query 'TargetHealthDescriptions[*].{Target:Target.Id,Health:TargetHealth.State}' \
              --output table 2>/dev/null || echo "No targets registered (service may be scaled to zero)"
          else
            echo "âš ï¸ Target group not found"
          fi

      - name: Deployment summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘            âœ… Staging Deployment Completed             â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“¦ Commit:     ${{ github.sha }}"
          echo "ğŸ·ï¸ Image tag:  ${{ needs.build-images.outputs.image_tag }}"
          echo "ğŸ—ï¸  Mode:       ECS Fargate"
          echo ""
          echo "ğŸŒ ALB URL:    http://${{ steps.alb.outputs.dns }}"
          echo "ğŸŒ Site URL:   https://${{ steps.ssm.outputs.site_domain }}"
          echo ""
          echo "ğŸ’¡ Note: First request may take 1-2 min if service was scaled to zero"
          echo ""
          echo "ğŸ—„ï¸ Config:     AWS SSM /city-guided/staging/*"
          echo ""
