name: architecture
version: "1.0.0"
description: Architecture principles for scalable and maintainable applications
tags: [architecture, mvp, hexagonal, monorepo]

rules:
  - id: mvp-first
    title: MVP-First Product Intent
    level: MUST
    content: |
      - Design MUST aim for the simplest possible MVP (time-to-first-feature) while preserving evolvability
      - Design MUST NOT over-optimize for unproven constraints (load, high availability, microservices, distributed cache, etc.)
      - If a technical constraint can be abstracted/deferred without endangering product trajectory, it MUST be deferred (accelerate development)

  - id: repo-structure
    title: Repository Structure (Conceptual)
    level: MUST
    content: |
      Codebase MUST separate conceptually:
      - Applications (entrypoints / delivery)
      - Runtime services (API/worker)
      - Shared libraries (reusable, pure)
      - Infrastructure (execution/deployment)
      
      For JS/TS monorepo (workspaces), structure SHOULD be:
      - apps/ (UI, backoffice, CLI, etc.)
      - services/ (API, workers)
      - packages/ (domain, shared libs)
      - infra/ (docker, provisioning IaC, scripts)
      
      If not JS/TS monorepo, structure MAY differ, but MUST preserve these 4 concepts (even if names change)

  - id: hexagonal-architecture
    title: Hexagonal Architecture (Ports & Adapters)
    level: MUST
    content: |
      Domain (entities, business rules, use-cases) MUST be:
      - Independent of frameworks
      - Testable without I/O
      - Stable facing adapter changes
      
      External dependencies (persistence, HTTP, providers, third-party systems) MUST be inverted via ports (interfaces) defined in domain/application layer
      
      Adapters (HTTP/controllers, DB repositories, external clients) MUST live in infrastructure layer
      
      Wiring (assembly ports/adapters, injection, config reading) MUST happen at the edge (service/app entrypoint), not in domain
      
      Shared libraries (packages/* or equivalent) MUST NOT read environment variables directly; configuration MUST come from apps/services

  - id: data-persistence-mvp
    title: Data & Persistence (MVP Approach)
    level: SHOULD
    content: |
      MVP MAY start with simple persistence (in-memory, file, mock), but:
      - Data access MUST go through a port (repository interface)
      - Concrete implementation (in-memory, file, DB) MUST be a replaceable adapter
      
      Design MUST NOT impose a "real DB" or cache from the start if the product doesn't need it
      
      Transition to a DB later SHOULD be an adapter substitution, not a domain rewrite

  - id: config-secrets-12factor
    title: Configuration, Secrets, and 12-Factor
    level: MUST
    content: |
      - Runtime configuration MUST be provided via environment variables (or equivalent runtime mechanism)
      - Secrets MUST NOT be committed; a configuration template MUST exist (without secrets)
      - Secrets SHOULD be distinguished (e.g., SECRET_ prefix) to facilitate:
        - Encrypted storage (secret manager / parameter store)
        - Audit and rotation
      - Logs MUST output to stdout/stderr, and be exploitable in local/CI/prod (readable or structured format)

  - id: containerization-local
    title: Containerization & Local Execution
    level: MUST
    content: |
      - Template MUST allow reproducible local startup (ideally "one-command")
      - If Docker is used:
        - Environment configuration SHOULD be based on .env.<env> files (or equivalent) with versioned .env.template
        - Critical services SHOULD expose healthcheck endpoints used by Compose/CI
      - A build-dedicated override file (e.g., docker-compose.build.yml) MAY exist, but IS NOT mandatory:
        - If single docker-compose.yml can cover "pull & run" and "build & run" via commands/variables, acceptable
        - Otherwise, an override remains a simple and readable solution
      - A single reverse-proxy/ingress entry point MAY be used (TLS, single access point, routing), but IS NOT a constraint: choose the most appropriate option

  - id: operational-scripts
    title: Operational Scripts (DX & Runbooks)
    level: SHOULD
    content: |
      - Template SHOULD provide operational scripts (bash or equivalent) to manage lifecycle:
        - setup, start, stop, logs, wait, deploy, clean (names adaptable)
      - These scripts MUST be called by project manager scripts (e.g., npm/pnpm scripts) and constitute the standard execution interface
      - Scripts SHOULD accept an environment parameter (local|ci|staging|prod) and apply corresponding config (.env.<env> or config store)

  - id: provisioning-deployment
    title: Provisioning / Deployment (Generic)
    level: SHOULD
    content: |
      - A staging environment SHOULD be provisioned via IaC (tool of choice) to avoid drift
      - Config and secrets SHOULD be centralized (secret manager / parameter store), with stable naming convention (e.g., /<project>/<env>/*)
      - Deployment SHOULD avoid manual SSH:
        - Prefer an authenticated remote execution mechanism (agent, session manager, runner, etc.)
        - And idempotent scripts

  - id: documentation-on-demand
    title: Documentation (On-Demand Only)
    level: MUST
    content: |
      - Documentation MUST be generated ONLY when explicitly requested by the user
      - When documentation is requested, it MUST be created in the docs/ directory
      - DO NOT create documentation files (.md) proactively without explicit user request
      - Exception: README.md files at package/module level for library usage are acceptable
